// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"fmt"
	"io"
	"strconv"

	"github.com/Laisky/laisky-blog-graphql/internal/web/blog/model"
	"github.com/Laisky/laisky-blog-graphql/library"
)

type BlogLoginResponse struct {
	User  *model.User `json:"user"`
	Token string      `json:"token"`
}

type Comment struct {
	ID            string            `json:"id"`
	Content       string            `json:"content"`
	AuthorName    string            `json:"authorName"`
	AuthorEmail   string            `json:"authorEmail"`
	AuthorWebsite *string           `json:"authorWebsite,omitempty"`
	PostID        string            `json:"postId"`
	ParentID      *string           `json:"parentId,omitempty"`
	CreatedAt     library.Datetime  `json:"createdAt"`
	UpdatedAt     *library.Datetime `json:"updatedAt,omitempty"`
	IsApproved    bool              `json:"isApproved"`
	Likes         int               `json:"likes"`
	Replies       []*Comment        `json:"replies,omitempty"`
}

type GeneralUser struct {
	Name         string   `json:"name"`
	LockPrefixes []string `json:"lock_prefixes"`
}

type Mutation struct {
}

type NewBlogPost struct {
	Name     string        `json:"name"`
	Title    *string       `json:"title,omitempty"`
	Markdown *string       `json:"markdown,omitempty"`
	Type     *BlogPostType `json:"type,omitempty"`
	Category *string       `json:"category,omitempty"`
	Language Language      `json:"language"`
}

type Pagination struct {
	Page int `json:"page"`
	Size int `json:"size"`
}

type Query struct {
}

type Sort struct {
	SortBy string    `json:"sort_by"`
	Order  SortOrder `json:"order"`
}

type UserActiveResponse struct {
	User  *model.User `json:"user"`
	Token string      `json:"token"`
}

type UserLoginResponse struct {
	User  *model.User `json:"user"`
	Token string      `json:"token"`
}

type UserRegisterResponse struct {
	Msg string `json:"msg"`
}

type UserResendActiveEmailResponse struct {
	Msg string `json:"msg"`
}

type WebFetchResult struct {
	URL       string           `json:"url"`
	CreatedAt library.Datetime `json:"created_at"`
	Content   string           `json:"content"`
}

type BlogPostType string

const (
	BlogPostTypeMarkdown BlogPostType = "markdown"
	BlogPostTypeSlide    BlogPostType = "slide"
	BlogPostTypeHTML     BlogPostType = "html"
)

var AllBlogPostType = []BlogPostType{
	BlogPostTypeMarkdown,
	BlogPostTypeSlide,
	BlogPostTypeHTML,
}

func (e BlogPostType) IsValid() bool {
	switch e {
	case BlogPostTypeMarkdown, BlogPostTypeSlide, BlogPostTypeHTML:
		return true
	}
	return false
}

func (e BlogPostType) String() string {
	return string(e)
}

func (e *BlogPostType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlogPostType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlogPostType", str)
	}
	return nil
}

func (e BlogPostType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BlogPostType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BlogPostType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Language string

const (
	LanguageZhCn Language = "zh_CN"
	LanguageEnUs Language = "en_US"
)

var AllLanguage = []Language{
	LanguageZhCn,
	LanguageEnUs,
}

func (e Language) IsValid() bool {
	switch e {
	case LanguageZhCn, LanguageEnUs:
		return true
	}
	return false
}

func (e Language) String() string {
	return string(e)
}

func (e *Language) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Language(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Language", str)
	}
	return nil
}

func (e Language) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Language) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Language) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortOrder) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortOrder) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
